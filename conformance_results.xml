<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="194" failures="11" skipped="0" tests="229" time="20.937" timestamp="2025-11-20T21:30:14.805926+05:30" hostname="rahul-G3-3590"><testcase classname="" name="tests.vector.test_deadline_enforcement" time="0.000"><error message="collection failure">tests/vector/test_deadline_enforcement.py:25: in &lt;module&gt;
    def get_remaining_budget_ms(ctx: OperationContext) -&gt; Optional[int]:
E   NameError: name 'Optional' is not defined</error><error message="collection failure">tests/vector/test_deadline_enforcement.py:25: in &lt;module&gt;
    def get_remaining_budget_ms(ctx: OperationContext) -&gt; Optional[int]:
E   NameError: name 'Optional' is not defined</error><error message="collection failure">tests/vector/test_deadline_enforcement.py:25: in &lt;module&gt;
    def get_remaining_budget_ms(ctx: OperationContext) -&gt; Optional[int]:
E   NameError: name 'Optional' is not defined</error><error message="collection failure">tests/vector/test_deadline_enforcement.py:25: in &lt;module&gt;
    def get_remaining_budget_ms(ctx: OperationContext) -&gt; Optional[int]:
E   NameError: name 'Optional' is not defined</error><error message="collection failure">tests/vector/test_deadline_enforcement.py:25: in &lt;module&gt;
    def get_remaining_budget_ms(ctx: OperationContext) -&gt; Optional[int]:
E   NameError: name 'Optional' is not defined</error><error message="collection failure">tests/vector/test_deadline_enforcement.py:25: in &lt;module&gt;
    def get_remaining_budget_ms(ctx: OperationContext) -&gt; Optional[int]:
E   NameError: name 'Optional' is not defined</error><error message="collection failure">tests/vector/test_deadline_enforcement.py:25: in &lt;module&gt;
    def get_remaining_budget_ms(ctx: OperationContext) -&gt; Optional[int]:
E   NameError: name 'Optional' is not defined</error><error message="collection failure">tests/vector/test_deadline_enforcement.py:25: in &lt;module&gt;
    def get_remaining_budget_ms(ctx: OperationContext) -&gt; Optional[int]:
E   NameError: name 'Optional' is not defined</error></testcase><testcase classname="" name="tests.graph.test_batch_operations" time="0.000"><error message="collection failure">ImportError while importing test module '/media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/graph/test_batch_operations.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
.venv/lib/python3.10/site-packages/_pytest/python.py:498: in importtestmodule
    mod = import_path(
.venv/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1050: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1027: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1006: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:688: in _load_unlocked
    ???
.venv/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:186: in exec_module
    exec(co, module.__dict__)
tests/graph/test_batch_operations.py:13: in &lt;module&gt;
    from corpus_sdk.graph.graph_base import (
E   ImportError: cannot import name 'BatchOperations' from 'corpus_sdk.graph.graph_base' (/media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/corpus_sdk/graph/graph_base.py)</error></testcase><testcase classname="" name="tests.graph.test_context_siem" time="0.000"><error message="collection failure">ImportError while importing test module '/media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/graph/test_context_siem.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
.venv/lib/python3.10/site-packages/_pytest/python.py:498: in importtestmodule
    mod = import_path(
.venv/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1050: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1027: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1006: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:688: in _load_unlocked
    ???
.venv/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:186: in exec_module
    exec(co, module.__dict__)
tests/graph/test_context_siem.py:18: in &lt;module&gt;
    from examples.common.ctx import make_ctx
E   ModuleNotFoundError: No module named 'examples'</error></testcase><testcase classname="" name="tests.graph.test_crud_basic" time="0.000"><error message="collection failure">ImportError while importing test module '/media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/graph/test_crud_basic.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
.venv/lib/python3.10/site-packages/_pytest/python.py:498: in importtestmodule
    mod = import_path(
.venv/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1050: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1027: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1006: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:688: in _load_unlocked
    ???
.venv/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:186: in exec_module
    exec(co, module.__dict__)
tests/graph/test_crud_basic.py:18: in &lt;module&gt;
    from examples.common.ctx import make_ctx
E   ModuleNotFoundError: No module named 'examples'</error></testcase><testcase classname="" name="tests.graph.test_deadline_enforcement" time="0.000"><error message="collection failure">ImportError while importing test module '/media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/graph/test_deadline_enforcement.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
.venv/lib/python3.10/site-packages/_pytest/python.py:498: in importtestmodule
    mod = import_path(
.venv/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1050: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1027: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1006: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:688: in _load_unlocked
    ???
.venv/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:186: in exec_module
    exec(co, module.__dict__)
tests/graph/test_deadline_enforcement.py:20: in &lt;module&gt;
    from examples.common.ctx import make_ctx, remaining_budget_ms, clear_time_cache
E   ModuleNotFoundError: No module named 'examples'</error></testcase><testcase classname="" name="tests.graph.test_dialect_validation" time="0.000"><error message="collection failure">ImportError while importing test module '/media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/graph/test_dialect_validation.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
.venv/lib/python3.10/site-packages/_pytest/python.py:498: in importtestmodule
    mod = import_path(
.venv/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1050: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1027: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1006: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:688: in _load_unlocked
    ???
.venv/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:186: in exec_module
    exec(co, module.__dict__)
tests/graph/test_dialect_validation.py:12: in &lt;module&gt;
    from corpus_sdk.examples.graph.mock_graph_adapter import MockGraphAdapter
E   ModuleNotFoundError: No module named 'corpus_sdk.examples.graph.mock_graph_adapter'</error></testcase><testcase classname="" name="tests.graph.test_error_mapping_retryable" time="0.000"><error message="collection failure">ImportError while importing test module '/media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/graph/test_error_mapping_retryable.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
.venv/lib/python3.10/site-packages/_pytest/python.py:498: in importtestmodule
    mod = import_path(
.venv/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1050: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1027: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1006: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:688: in _load_unlocked
    ???
.venv/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:186: in exec_module
    exec(co, module.__dict__)
tests/graph/test_error_mapping_retryable.py:12: in &lt;module&gt;
    from corpus_sdk.graph.graph_base import (
E   ImportError: cannot import name 'AdapterError' from 'corpus_sdk.graph.graph_base' (/media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/corpus_sdk/graph/graph_base.py)</error></testcase><testcase classname="" name="tests.graph.test_health_report" time="0.000"><error message="collection failure">ImportError while importing test module '/media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/graph/test_health_report.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
.venv/lib/python3.10/site-packages/_pytest/python.py:498: in importtestmodule
    mod = import_path(
.venv/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1050: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1027: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1006: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:688: in _load_unlocked
    ???
.venv/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:186: in exec_module
    exec(co, module.__dict__)
tests/graph/test_health_report.py:13: in &lt;module&gt;
    from corpus_sdk.graph.graph_base import (
E   ImportError: cannot import name 'HealthStatus' from 'corpus_sdk.graph.graph_base' (/media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/corpus_sdk/graph/graph_base.py)</error></testcase><testcase classname="" name="tests.graph.test_query_basic" time="0.000"><error message="collection failure">ImportError while importing test module '/media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/graph/test_query_basic.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
.venv/lib/python3.10/site-packages/_pytest/python.py:498: in importtestmodule
    mod = import_path(
.venv/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1050: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1027: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1006: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:688: in _load_unlocked
    ???
.venv/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:186: in exec_module
    exec(co, module.__dict__)
tests/graph/test_query_basic.py:18: in &lt;module&gt;
    from examples.common.ctx import make_ctx, clear_time_cache
E   ModuleNotFoundError: No module named 'examples'</error></testcase><testcase classname="" name="tests.graph.test_schema_operations" time="0.000"><error message="collection failure">ImportError while importing test module '/media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/graph/test_schema_operations.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
.venv/lib/python3.10/site-packages/_pytest/python.py:498: in importtestmodule
    mod = import_path(
.venv/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1050: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1027: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1006: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:688: in _load_unlocked
    ???
.venv/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:186: in exec_module
    exec(co, module.__dict__)
tests/graph/test_schema_operations.py:17: in &lt;module&gt;
    from examples.common.ctx import make_ctx
E   ModuleNotFoundError: No module named 'examples'</error></testcase><testcase classname="" name="tests.graph.test_streaming_semantics" time="0.000"><error message="collection failure">ImportError while importing test module '/media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/graph/test_streaming_semantics.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
.venv/lib/python3.10/site-packages/_pytest/python.py:498: in importtestmodule
    mod = import_path(
.venv/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1050: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1027: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1006: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:688: in _load_unlocked
    ???
.venv/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:186: in exec_module
    exec(co, module.__dict__)
tests/graph/test_streaming_semantics.py:20: in &lt;module&gt;
    from examples.common.ctx import make_ctx, clear_time_cache
E   ModuleNotFoundError: No module named 'examples'</error></testcase><testcase classname="" name="tests.embedding.test_cache_and_batch_fallback" time="0.000"><error message="collection failure">ImportError while importing test module '/media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/embedding/test_cache_and_batch_fallback.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
.venv/lib/python3.10/site-packages/_pytest/python.py:498: in importtestmodule
    mod = import_path(
.venv/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1050: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1027: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1006: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:688: in _load_unlocked
    ???
.venv/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:186: in exec_module
    exec(co, module.__dict__)
tests/embedding/test_cache_and_batch_fallback.py:27: in &lt;module&gt;
    from examples.common.ctx import make_ctx
E   ModuleNotFoundError: No module named 'examples'</error></testcase><testcase classname="" name="tests.embedding.test_capabilities_shape" time="0.000"><error message="collection failure">import file mismatch:
imported module 'test_capabilities_shape' has this __file__ attribute:
  /media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/vector/test_capabilities_shape.py
which is not the same as the test file we want to collect:
  /media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/embedding/test_capabilities_shape.py
HINT: remove __pycache__ / .pyc files and/or use a unique basename for your test file modules</error></testcase><testcase classname="" name="tests.embedding.test_context_siem" time="0.000"><error message="collection failure">import file mismatch:
imported module 'test_context_siem' has this __file__ attribute:
  /media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/vector/test_context_siem.py
which is not the same as the test file we want to collect:
  /media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/embedding/test_context_siem.py
HINT: remove __pycache__ / .pyc files and/or use a unique basename for your test file modules</error></testcase><testcase classname="" name="tests.embedding.test_count_tokens_behavior" time="0.000"><error message="collection failure">ImportError while importing test module '/media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/embedding/test_count_tokens_behavior.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
.venv/lib/python3.10/site-packages/_pytest/python.py:498: in importtestmodule
    mod = import_path(
.venv/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1050: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1027: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1006: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:688: in _load_unlocked
    ???
.venv/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:186: in exec_module
    exec(co, module.__dict__)
tests/embedding/test_count_tokens_behavior.py:21: in &lt;module&gt;
    from examples.common.ctx import make_ctx
E   ModuleNotFoundError: No module named 'examples'</error></testcase><testcase classname="" name="tests.embedding.test_deadline_enforcement" time="0.000"><error message="collection failure">ImportError while importing test module '/media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/embedding/test_deadline_enforcement.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
.venv/lib/python3.10/site-packages/_pytest/python.py:498: in importtestmodule
    mod = import_path(
.venv/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1050: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1027: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1006: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:688: in _load_unlocked
    ???
.venv/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:186: in exec_module
    exec(co, module.__dict__)
tests/embedding/test_deadline_enforcement.py:25: in &lt;module&gt;
    from examples.common.ctx import make_ctx, remaining_budget_ms, clear_time_cache
E   ModuleNotFoundError: No module named 'examples'</error></testcase><testcase classname="" name="tests.embedding.test_embed_basic" time="0.000"><error message="collection failure">ImportError while importing test module '/media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/embedding/test_embed_basic.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
.venv/lib/python3.10/site-packages/_pytest/python.py:498: in importtestmodule
    mod = import_path(
.venv/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1050: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1027: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1006: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:688: in _load_unlocked
    ???
.venv/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:186: in exec_module
    exec(co, module.__dict__)
tests/embedding/test_embed_basic.py:25: in &lt;module&gt;
    from examples.common.ctx import make_ctx
E   ModuleNotFoundError: No module named 'examples'</error></testcase><testcase classname="" name="tests.embedding.test_embed_batch_basic" time="0.000"><error message="collection failure">ImportError while importing test module '/media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/embedding/test_embed_batch_basic.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
.venv/lib/python3.10/site-packages/_pytest/python.py:498: in importtestmodule
    mod = import_path(
.venv/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1050: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1027: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1006: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:688: in _load_unlocked
    ???
.venv/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:186: in exec_module
    exec(co, module.__dict__)
tests/embedding/test_embed_batch_basic.py:27: in &lt;module&gt;
    from examples.common.ctx import make_ctx
E   ModuleNotFoundError: No module named 'examples'</error></testcase><testcase classname="" name="tests.embedding.test_error_mapping_retryable" time="0.000"><error message="collection failure">import file mismatch:
imported module 'test_error_mapping_retryable' has this __file__ attribute:
  /media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/vector/test_error_mapping_retryable.py
which is not the same as the test file we want to collect:
  /media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/embedding/test_error_mapping_retryable.py
HINT: remove __pycache__ / .pyc files and/or use a unique basename for your test file modules</error></testcase><testcase classname="" name="tests.embedding.test_health_report" time="0.000"><error message="collection failure">import file mismatch:
imported module 'test_health_report' has this __file__ attribute:
  /media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/vector/test_health_report.py
which is not the same as the test file we want to collect:
  /media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/embedding/test_health_report.py
HINT: remove __pycache__ / .pyc files and/or use a unique basename for your test file modules</error></testcase><testcase classname="" name="tests.embedding.test_normalization_semantics" time="0.000"><error message="collection failure">ImportError while importing test module '/media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/embedding/test_normalization_semantics.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
.venv/lib/python3.10/site-packages/_pytest/python.py:498: in importtestmodule
    mod = import_path(
.venv/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1050: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1027: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1006: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:688: in _load_unlocked
    ???
.venv/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:186: in exec_module
    exec(co, module.__dict__)
tests/embedding/test_normalization_semantics.py:22: in &lt;module&gt;
    from examples.common.ctx import make_ctx
E   ModuleNotFoundError: No module named 'examples'</error></testcase><testcase classname="" name="tests.embedding.test_truncation_and_text_length" time="0.000"><error message="collection failure">ImportError while importing test module '/media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/embedding/test_truncation_and_text_length.py'.
Hint: make sure your test modules/packages have valid Python names.
Traceback:
.venv/lib/python3.10/site-packages/_pytest/python.py:498: in importtestmodule
    mod = import_path(
.venv/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/usr/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1050: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1027: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1006: in _find_and_load_unlocked
    ???
&lt;frozen importlib._bootstrap&gt;:688: in _load_unlocked
    ???
.venv/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:186: in exec_module
    exec(co, module.__dict__)
tests/embedding/test_truncation_and_text_length.py:22: in &lt;module&gt;
    from examples.common.ctx import make_ctx
E   ModuleNotFoundError: No module named 'examples'</error></testcase><testcase classname="" name="tests.embedding.test_wire_handler" time="0.000"><error message="collection failure">import file mismatch:
imported module 'test_wire_handler' has this __file__ attribute:
  /media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/vector/test_wire_handler.py
which is not the same as the test file we want to collect:
  /media/rahul/514150442B0A5F0612/ahrvo/corpus-protocol-suite/tests/embedding/test_wire_handler.py
HINT: remove __pycache__ / .pyc files and/or use a unique basename for your test file modules</error></testcase><testcase classname="tests.llm.test_capabilities_shape" name="test_capabilities_consistency_with_count_tokens" time="0.023"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_context_siem" name="test_observability_context_propagates_to_metrics_siem_safe" time="0.031"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_count_tokens_consistency" name="test_token_counting_count_tokens_monotonic" time="0.026"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_health_report" name="test_health_health_deadline_preexpired_raises_deadline_exceeded" time="0.019"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_complete_basic" name="test_core_ops_complete_basic_text_and_usage" time="0.017"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_capabilities_shape" name="test_capabilities_capabilities_shape_and_required_fields" time="0.040"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_error_mapping_retryable" name="test_error_handling_bad_request_is_non_retryable_and_no_retry_after" time="0.024"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_deadline_enforcement" name="test_deadline_deadline_budget_nonnegative_and_usable" time="0.036"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_capabilities_shape" name="test_capabilities_consistency_with_streaming" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_complete_basic" name="test_core_ops_complete_different_message_structures" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_health_report" name="test_health_health_includes_optional_uptime_if_provided" time="0.006"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_deadline_enforcement" name="test_deadline_deadline_exceeded_on_expired_budget" time="0.006"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_error_mapping_retryable" name="test_error_handling_deadline_exceeded_is_conditionally_retryable_with_no_chunks" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_context_siem" name="test_observability_metrics_emitted_on_error_path" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_capabilities_shape" name="test_capabilities_returns_correct_type" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_count_tokens_consistency" name="test_token_counting_empty_string" time="0.007"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_capabilities_shape" name="test_capabilities_all_fields_present" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_complete_basic" name="test_core_ops_complete_empty_messages_rejected" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_health_report" name="test_health_health_includes_optional_details_if_provided" time="0.005"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_context_siem" name="test_observability_streaming_metrics_siem_safe" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_error_mapping_retryable" name="test_error_handling_retryable_error_attributes_minimum_shape" time="0.005"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_deadline_enforcement" name="test_deadline_deadline_exceeded_during_stream" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_capabilities_shape" name="test_capabilities_identity_fields" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_count_tokens_consistency" name="test_token_counting_unicode_handling" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_capabilities_shape" name="test_capabilities_idempotency" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_complete_basic" name="test_core_ops_complete_response_contains_expected_fields" time="0.010"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_message_validation" name="test_message_validation_empty_messages_list_rejected" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_context_siem" name="test_observability_token_counter_metrics_present" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_health_report" name="test_health_health_has_required_fields" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_deadline_enforcement" name="test_deadline_operations_complete_with_adequate_budget" time="0.017"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_capabilities_shape" name="test_capabilities_resource_limits" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_count_tokens_consistency" name="test_token_counting_whitespace_variations" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_capabilities_shape" name="test_capabilities_reasonable_model_names" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_complete_basic" name="test_core_ops_complete_usage_accounting_consistent" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_message_validation" name="test_message_validation_missing_role_field_rejected" time="0.005"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_context_siem" name="test_observability_metrics_structure_consistency" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_health_report" name="test_health_health_shape_consistent_when_degraded" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_deadline_enforcement" name="test_deadline_budget_calculation_accuracy" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_capabilities_shape" name="test_capabilities_no_duplicate_models" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_capabilities_shape" name="test_capabilities_feature_flags_are_boolean" time="0.007"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_count_tokens_consistency" name="test_token_counting_consistent_for_identical_inputs" time="0.005"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_complete_basic" name="test_core_ops_complete_different_models_produce_results" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_message_validation" name="test_message_validation_missing_content_field_rejected" time="0.021"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_context_siem" name="test_observability_no_metric_leakage_between_tenants" time="0.009"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_health_report" name="test_health_health_identity_fields_are_stable_across_calls" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_error_mapping_retryable" name="test_error_handling_retryable_errors_with_hints" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_message_validation" name="test_message_validation_invalid_role_rejected" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_capabilities_shape" name="test_capabilities_supported_models_structure" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_count_tokens_consistency" name="test_token_counting_respects_context_limits" time="0.009"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_message_validation" name="test_message_validation_mixed_invalid_and_valid_rejected" time="0.005"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_invalid_temperature_rejected[999.0]" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_invalid_top_p_rejected[-0.1]" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_valid_top_p_accepted[1.0]" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_valid_frequency_penalty_accepted[-1.0]" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_valid_presence_penalty_accepted[1.0]" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_message_validation" name="test_message_validation_valid_roles_accepted" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_invalid_presence_penalty_rejected[-3.0]" time="0.008"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_valid_temperature_accepted[0.0]" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_message_validation" name="test_message_validation_error_messages_are_descriptive" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_invalid_top_p_rejected[1.1]" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_invalid_frequency_penalty_rejected[-2.1]" time="0.020"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_valid_frequency_penalty_accepted[0.0]" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_valid_presence_penalty_accepted[2.0]" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_invalid_presence_penalty_rejected[5.0]" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_message_validation" name="test_message_validation_system_role_requires_capability" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_message_validation" name="test_message_validation_whitespace_only_content_rejected" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_valid_temperature_accepted[0.5]" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_invalid_top_p_rejected[2.0]" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_invalid_frequency_penalty_rejected[2.1]" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_valid_frequency_penalty_accepted[1.0]" time="0.009"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_multiple_invalid_params_error_message" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_valid_presence_penalty_accepted[-2.0]" time="0.006"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_message_validation" name="test_message_validation_max_reasonable_messages_accepted" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_message_validation" name="test_message_validation_empty_content_rejected_for_user_role" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_valid_temperature_accepted[1.0]" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_invalid_top_p_rejected[-1.0]" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_invalid_frequency_penalty_rejected[-3.0]" time="0.007"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_streaming_semantics" name="test_streaming_stream_has_single_final_chunk_and_progress_usage" time="0.003"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_valid_frequency_penalty_accepted[2.0]" time="0.007"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_invalid_temperature_rejected[-0.1]" time="0.011"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_valid_presence_penalty_accepted[-1.0]" time="0.006"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_message_validation" name="test_message_validation_content_too_large_rejected" time="0.005"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_valid_temperature_accepted[1.5]" time="0.006"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_valid_top_p_accepted[0.1]" time="0.009"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_invalid_frequency_penalty_rejected[5.0]" time="0.005"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_streaming_semantics" name="test_streaming_stream_model_consistent_when_present" time="0.007"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_invalid_presence_penalty_rejected[-2.1]" time="0.006"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_valid_presence_penalty_accepted[0.0]" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_wire_handler" name="test_wire_contract_complete_roundtrip_and_context_plumbing" time="0.006" /><testcase classname="tests.llm.test_wire_handler" name="test_wire_contract_count_tokens_and_health_envelopes" time="0.005" /><testcase classname="tests.llm.test_wire_handler" name="test_wire_contract_stream_success_chunks_and_context" time="0.004" /><testcase classname="tests.llm.test_wire_handler" name="test_wire_contract_unknown_op_maps_to_not_supported" time="0.004" /><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_invalid_temperature_rejected[2.1]" time="0.013"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_message_validation" name="test_message_validation_valid_content_types_accepted" time="0.005"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_valid_top_p_accepted[0.5]" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_valid_frequency_penalty_accepted[-2.0]" time="0.006"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_wire_handler" name="test_wire_contract_missing_or_invalid_op_maps_to_bad_request" time="0.009" /><testcase classname="tests.llm.test_streaming_semantics" name="test_streaming_stream_early_cancel_then_new_stream_ok" time="0.009"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_valid_temperature_accepted[2.0]" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_wire_handler" name="test_wire_contract_maps_llm_adapter_error_to_normalized_envelope" time="0.007" /><testcase classname="tests.llm.test_wire_handler" name="test_wire_contract_maps_unexpected_exception_to_unavailable" time="0.005" /><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_invalid_presence_penalty_rejected[2.1]" time="0.005"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_invalid_temperature_rejected[-1.0]" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_capabilities_shape" name="test_capabilities_identity_fields" time="0.006"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_message_validation" name="test_message_validation_conversation_structure_accepted" time="0.006"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_streaming_semantics" name="test_streaming_stream_deadline_preexpired_yields_no_chunks" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_valid_top_p_accepted[0.9]" time="0.008"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_sampling_params_validation" name="test_sampling_params_invalid_top_p_rejected[0.0]" time="0.005"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_batch_size_limits" name="test_batch_limits_batch_size_exceeded_includes_suggestion" time="0.006"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_batch_size_limits" name="test_batch_limits_upsert_respects_max_batch_size" time="0.005"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_capabilities_shape" name="test_capabilities_supported_metrics" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_capabilities_shape" name="test_capabilities_idempotent_calls" time="0.007"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_message_validation" name="test_message_validation_tool_role_requires_tool_call_id" time="0.009"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_context_siem" name="test_observability_query_metrics_include_namespace" time="0.007"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_streaming_semantics" name="test_streaming_stream_content_progress_and_terminal_rules" time="0.007"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_delete_operations" name="test_delete_delete_by_filter_returns_counts" time="0.005"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_context_siem" name="test_observability_tenant_hashed_never_raw" time="0.006"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_batch_size_limits" name="test_batch_limits_partial_failure_reporting_shape" time="0.017"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_delete_operations" name="test_delete_delete_result_structure" time="0.007"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_capabilities_shape" name="test_capabilities_resource_limits_positive" time="0.013"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_capabilities_shape" name="test_capabilities_all_required_fields_present" time="0.013"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_delete_operations" name="test_delete_requires_ids_or_filter" time="0.005"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_context_siem" name="test_observability_upsert_metrics_include_vector_count" time="0.006"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_context_siem" name="test_observability_no_vector_data_in_metrics" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_streaming_semantics" name="test_streaming_stream_body_matches_complete_result" time="0.010"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.llm.test_wire_handler" name="test_wire_contract_capabilities_success_envelope" time="0.011" /><testcase classname="tests.vector.test_batch_size_limits" name="test_batch_limits_batch_operations_atomic_per_vector" time="0.015"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_dimension_validation" name="test_dimension_validation_dimension_mismatch_on_upsert" time="0.011"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_capabilities_shape" name="test_capabilities_feature_flags_boolean" time="0.006"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_context_siem" name="test_observability_context_propagates_to_metrics_siem_safe" time="0.006"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_delete_operations" name="test_delete_delete_by_ids_returns_counts" time="0.007"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_error_mapping_retryable" name="test_error_handling_index_not_ready_retryable" time="0.011" /><testcase classname="tests.vector.test_error_mapping_retryable" name="test_error_handling_dimension_mismatch_non_retryable_flag" time="0.014" /><testcase classname="tests.vector.test_delete_operations" name="test_delete_idempotent_for_missing_ids" time="0.014"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_context_siem" name="test_observability_metrics_emitted_on_error_path" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_dimension_validation" name="test_dimension_validation_dimension_mismatch_on_query" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_filtering_semantics" name="test_filtering_filter_empty_results_ok" time="0.007"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_capabilities_shape" name="test_capabilities_capabilities_returns_correct_type" time="0.005"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_dimension_validation" name="test_dimension_validation_dimension_mismatch_error_attributes" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_filtering_semantics" name="test_filtering_query_filter_equality" time="0.006"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_namespace_operations" name="test_namespace_create_namespace_returns_success" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_error_mapping_retryable" name="test_error_handling_bad_request_on_invalid_top_k" time="0.014"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_error_mapping_retryable" name="test_error_handling_error_has_siem_safe_details" time="0.006" /><testcase classname="tests.vector.test_filtering_semantics" name="test_filtering_filter_requires_mapping_type" time="0.011"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_health_report" name="test_health_shape_consistent_on_error" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_health_report" name="test_health_health_returns_required_fields" time="0.011"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_dimension_validation" name="test_dimension_validation_dimension_mismatch_non_retryable" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_error_mapping_retryable" name="test_error_handling_retryable_errors_with_hints" time="0.004" /><testcase classname="tests.vector.test_health_report" name="test_health_health_includes_namespaces" time="0.006"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_filtering_semantics" name="test_filtering_delete_filter_equality" time="0.005"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_namespace_operations" name="test_namespace_namespace_requires_positive_dimensions" time="0.020"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_namespace_operations" name="test_namespace_namespace_isolation" time="0.015"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_filtering_semantics" name="test_filtering_filter_respects_capabilities_support" time="0.006"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_health_report" name="test_health_identity_fields_stable" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_query_basic" name="test_query_results_sorted_by_score_desc" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_namespace_operations" name="test_namespace_namespace_requires_valid_distance_metric" time="0.008"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_health_report" name="test_health_status_ok_bool" time="0.006"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_namespace_operations" name="test_namespace_health_exposes_namespaces_dict" time="0.007"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_namespace_operations" name="test_namespace_delete_namespace_idempotent" time="0.010"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_query_basic" name="test_query_query_returns_vector_matches" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_query_basic" name="test_query_top_k_must_be_positive" time="0.006"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_wire_handler" name="test_wire_contract_capabilities_success_envelope" time="0.012"><failure message="assert False is True">async def test_wire_contract_capabilities_success_envelope():
        """Verify capabilities operation returns proper success envelope."""
        adapter = TrackingMockVectorAdapter()
        handler = WireVectorHandler(adapter)
    
        envelope = {
            "op": "vector.capabilities",
            "ctx": {},
            "args": {},
        }
        result = await handler.handle(envelope)
    
&gt;       assert result["ok"] is True
E       assert False is True

tests/vector/test_wire_handler.py:150: AssertionError</failure></testcase><testcase classname="tests.vector.test_query_basic" name="test_query_validates_dimensions" time="0.006"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_query_basic" name="test_query_include_flags_respected" time="0.005"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_wire_handler" name="test_wire_contract_query_roundtrip_and_context_plumbing" time="0.007"><failure message="assert False is True">async def test_wire_contract_query_roundtrip_and_context_plumbing():
        """Verify query operation with context propagation."""
        adapter = TrackingMockVectorAdapter()
        handler = WireVectorHandler(adapter)
    
        wire_context = {
            "request_id": "test-request-123",
            "idempotency_key": "test-idempotency",
            "deadline_ms": 9999999999999,
            "traceparent": "00-test-trace-01",
            "tenant": "test-tenant",
            "attrs": {"test_key": "test_value"},
            "ignore_field": "should-be-ignored",  # Must be filtered out
        }
    
        args = {
            "vector": [0.1, 0.2],
            "top_k": 3,
            "namespace": "default",
            "include_metadata": True,
            "include_vectors": False,
        }
    
        result = await handler.handle({
            "op": "vector.query",
            "ctx": wire_context,
            "args": args,
        })
    
        # Verify success envelope
&gt;       assert result["ok"] is True
E       assert False is True

tests/vector/test_wire_handler.py:188: AssertionError</failure></testcase><testcase classname="tests.vector.test_wire_handler" name="test_wire_contract_missing_or_invalid_op_maps_to_bad_request" time="0.009" /><testcase classname="tests.vector.test_upsert_basic" name="test_upsert_upsert_returns_result_with_counts" time="0.010"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_query_basic" name="test_query_respects_max_top_k" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_wire_handler" name="test_wire_contract_query_missing_required_fields_maps_to_bad_request" time="0.018"><failure message="AssertionError: assert 'UNAVAILABLE' == 'BAD_REQUEST'&#10;  &#10;  - BAD_REQUEST&#10;  + UNAVAILABLE">async def test_wire_contract_query_missing_required_fields_maps_to_bad_request():
        """Verify missing required fields in query return BAD_REQUEST."""
        adapter = TrackingMockVectorAdapter()
        handler = WireVectorHandler(adapter)
    
        result = await handler.handle({
            "op": "vector.query",
            "ctx": {},
            "args": {},  # Missing required fields
        })
    
        assert result["ok"] is False
&gt;       assert result["code"] == "BAD_REQUEST"
E       AssertionError: assert 'UNAVAILABLE' == 'BAD_REQUEST'
E         
E         - BAD_REQUEST
E         + UNAVAILABLE

tests/vector/test_wire_handler.py:416: AssertionError</failure></testcase><testcase classname="tests.vector.test_wire_handler" name="test_wire_contract_delete_namespace_operation" time="0.015"><failure message="assert False is True">async def test_wire_contract_delete_namespace_operation():
        """Verify delete_namespace operation returns proper success envelope."""
        adapter = TrackingMockVectorAdapter()
        handler = WireVectorHandler(adapter)
    
        result = await handler.handle({
            "op": "vector.delete_namespace",
            "ctx": {"request_id": "delete-namespace-test"},
            "args": {
                "namespace": "test-namespace-to-delete",
            },
        })
    
        # Verify success envelope
&gt;       assert result["ok"] is True
E       assert False is True

tests/vector/test_wire_handler.py:269: AssertionError</failure></testcase><testcase classname="tests.vector.test_wire_handler" name="test_wire_contract_upsert_delete_namespace_health_envelopes" time="0.010"><failure message="assert False is True">async def test_wire_contract_upsert_delete_namespace_health_envelopes():
        """Verify all vector operations return proper success envelopes."""
        adapter = TrackingMockVectorAdapter()
        handler = WireVectorHandler(adapter)
    
        # Test upsert operation
        upsert_result = await handler.handle({
            "op": "vector.upsert",
            "ctx": {"request_id": "upsert-test"},
            "args": {
                "namespace": "test-namespace",
                "vectors": [{"id": "v1", "vector": [0.1, 0.2]}],
            },
        })
&gt;       assert upsert_result["ok"] is True
E       assert False is True

tests/vector/test_wire_handler.py:216: AssertionError</failure></testcase><testcase classname="tests.vector.test_wire_handler" name="test_wire_contract_error_envelope_includes_message_and_type" time="0.005" /><testcase classname="tests.vector.test_upsert_basic" name="test_upsert_validates_dimensions" time="0.004"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_wire_handler" name="test_wire_contract_unknown_op_maps_to_not_supported" time="0.012" /><testcase classname="tests.vector.test_upsert_basic" name="test_upsert_validates_namespace_exists_or_behavior_documented" time="0.005"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_wire_handler" name="test_wire_contract_maps_vector_adapter_error_to_normalized_envelope" time="0.005" /><testcase classname="tests.graph.test_wire_handler" name="test_wire_contract_get_schema_envelope_success" time="0.014"><failure message="assert False is True">async def test_wire_contract_get_schema_envelope_success():
        """4.1: Schema operation must return valid success envelope."""
        a = TrackingMockGraphAdapter()
        h = WireGraphHandler(a)
    
        res = await h.handle(
            {
                "op": "graph.get_schema",
                "ctx": {"request_id": "schema-only"},
                "args": {},
            }
        )
    
&gt;       assert res["ok"] is True
E       assert False is True

tests/graph/test_wire_handler.py:375: AssertionError</failure></testcase><testcase classname="tests.vector.test_upsert_basic" name="test_upsert_requires_non_empty_vectors" time="0.015"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.vector.test_wire_handler" name="test_wire_contract_maps_unexpected_exception_to_unavailable" time="0.007" /><testcase classname="tests.graph.test_wire_handler" name="test_wire_contract_unknown_op_maps_to_not_supported" time="0.013" /><testcase classname="tests.graph.test_wire_handler" name="test_wire_contract_missing_or_invalid_op_maps_to_bad_request" time="0.004" /><testcase classname="tests.graph.test_wire_handler" name="test_wire_contract_query_missing_required_fields_maps_to_bad_request" time="0.014"><failure message="AssertionError: assert 'UNAVAILABLE' == 'BAD_REQUEST'&#10;  &#10;  - BAD_REQUEST&#10;  + UNAVAILABLE">async def test_wire_contract_query_missing_required_fields_maps_to_bad_request():
        """6.3: Missing required fields must return BAD_REQUEST."""
        a = TrackingMockGraphAdapter()
        h = WireGraphHandler(a)
    
        res = await h.handle(
            {
                "op": "graph.query",
                "ctx": {},
                "args": {},  # missing required 'text'
            }
        )
    
        assert res["ok"] is False
&gt;       assert res["code"] == "BAD_REQUEST"
E       AssertionError: assert 'UNAVAILABLE' == 'BAD_REQUEST'
E         
E         - BAD_REQUEST
E         + UNAVAILABLE

tests/graph/test_wire_handler.py:485: AssertionError</failure></testcase><testcase classname="tests.vector.test_upsert_basic" name="test_upsert_partial_failure_reporting" time="0.013"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.graph.test_capabilities_shape" name="test_capabilities_feature_flags_are_boolean" time="0.007"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.graph.test_wire_handler" name="test_wire_contract_stream_query_success_chunks_and_context" time="0.008"><failure message="assert False is True">async def test_wire_contract_stream_query_success_chunks_and_context():
        """4.1.6: Stream query must return valid chunk envelopes."""
        a = TrackingMockGraphAdapter()
        h = WireGraphHandler(a)
    
        env = {
            "op": "graph.stream_query",
            "ctx": {
                "request_id": "stream-1",
                "tenant": "stream-tenant",
            },
            "args": {
                "text": "MATCH (n) RETURN n",
                "dialect": "cypher",
                "namespace": "demo",
                "params": {},
                "timeout_ms": 1000,
                "stream": True,
            },
        }
    
        chunks: List[Dict[str, Any]] = []
        async for envelope in h.handle_stream(env):
            chunks.append(envelope)
    
        # Expect at least one chunk
        assert len(chunks) &gt;= 1
    
        for env_out in chunks:
&gt;           assert env_out["ok"] is True
E           assert False is True

tests/graph/test_wire_handler.py:415: AssertionError</failure></testcase><testcase classname="tests.vector.test_wire_handler" name="test_wire_contract_maps_not_supported_adapter_error" time="0.007" /><testcase classname="tests.graph.test_wire_handler" name="test_wire_contract_maps_unexpected_exception_to_unavailable" time="0.010" /><testcase classname="tests.graph.test_wire_handler" name="test_wire_contract_maps_graph_adapter_error_to_normalized_envelope" time="0.008" /><testcase classname="tests.graph.test_capabilities_shape" name="test_capabilities_identity_fields" time="0.008"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.graph.test_capabilities_shape" name="test_capabilities_rate_limit_unit" time="0.011"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.graph.test_capabilities_shape" name="test_capabilities_returns_correct_type" time="0.009"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.graph.test_wire_handler" name="test_wire_contract_error_envelope_includes_message_and_type" time="0.014" /><testcase classname="tests.graph.test_wire_handler" name="test_wire_contract_upsert_delete_bulk_batch_schema_health_envelopes" time="0.007"><failure message="assert False is True">async def test_wire_contract_upsert_delete_bulk_batch_schema_health_envelopes():
        """4.1: All graph operations must return valid success envelopes."""
        a = TrackingMockGraphAdapter()
        h = WireGraphHandler(a)
    
        # upsert_nodes
        up_nodes_env = {
            "op": "graph.upsert_nodes",
            "ctx": {"request_id": "up-n"},
            "args": {
                "namespace": "ns1",
                "nodes": [
                    {
                        "id": "n1",
                        "labels": ["User"],
                        "properties": {"name": "alice"},
                        "namespace": "ns1",
                    }
                ],
            },
        }
        up_nodes_res = await h.handle(up_nodes_env)
&gt;       assert up_nodes_res["ok"] is True
E       assert False is True

tests/graph/test_wire_handler.py:247: AssertionError</failure></testcase><testcase classname="tests.graph.test_wire_handler" name="test_wire_contract_capabilities_success_envelope" time="0.012"><failure message="assert False is True">async def test_wire_contract_capabilities_success_envelope():
        """4.1: Capabilities operation must return valid success envelope."""
        a = TrackingMockGraphAdapter()
        h = WireGraphHandler(a)
    
        env = {
            "op": "graph.capabilities",
            "ctx": {},
            "args": {},
        }
        res = await h.handle(env)
    
&gt;       assert res["ok"] is True
E       assert False is True

tests/graph/test_wire_handler.py:167: AssertionError</failure></testcase><testcase classname="tests.graph.test_capabilities_shape" name="test_capabilities_dialects_tuple" time="0.006"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.graph.test_wire_handler" name="test_wire_contract_query_roundtrip_and_context_plumbing" time="0.006"><failure message="assert False is True">async def test_wire_contract_query_roundtrip_and_context_plumbing():
        """6.1: OperationContext must be properly propagated through wire handler."""
        a = TrackingMockGraphAdapter()
        h = WireGraphHandler(a)
    
        ctx_wire = {
            "request_id": "req_wire_graph",
            "idempotency_key": "idem-graph",
            "deadline_ms": 9999999999999,
            "traceparent": "00-abc-xyz-01",
            "tenant": "acme-tenant",
            "attrs": {"k": "v"},
            "ignore_me": "extra",  # MUST be ignored
        }
        args = {
            "text": "MATCH (n) RETURN n LIMIT 1",
            "dialect": "cypher",
            "namespace": "demo",
            "params": {"foo": "bar"},
            "timeout_ms": 1000,
            "stream": False,
        }
    
        res = await h.handle(
            {
                "op": "graph.query",
                "ctx": ctx_wire,
                "args": args,
            }
        )
    
&gt;       assert res["ok"] is True
E       assert False is True

tests/graph/test_wire_handler.py:208: AssertionError</failure></testcase><testcase classname="tests.graph.test_capabilities_shape" name="test_capabilities_max_batch_ops_valid" time="0.005"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase><testcase classname="tests.graph.test_wire_handler" name="test_wire_contract_maps_notsupported_adapter_error_to_not_supported_code" time="0.009" /><testcase classname="tests.graph.test_capabilities_shape" name="test_capabilities_idempotency" time="0.021"><error message="failed on setup with &quot;conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.&quot;">spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
&gt;           module = importlib.import_module(module_name)

tests/conftest.py:593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'tests.mocks.mock_llm_adapter', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'tests'

/usr/lib/python3.10/importlib/__init__.py:126: ModuleNotFoundError

The above exception was the direct cause of the following exception:

    @pytest.fixture
    def adapter():
        """
        Generic, pluggable adapter fixture with enhanced validation.
        """
&gt;       Adapter = _get_adapter_class()

tests/conftest.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:626: in _get_adapter_class
    _ADAPTER_CLASS = _load_class_from_spec(spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = 'tests.mocks.mock_llm_adapter:MockLLMAdapter'

    def _load_class_from_spec(spec: str) -&gt; type:
        """
        Load and validate a class from a 'package.module:ClassName' string.
        """
        module_name, _, class_name = spec.partition(':')
        if not module_name or not class_name:
            raise AdapterValidationError(
                f"Invalid adapter spec '{spec}'. Expected 'package.module:ClassName'."
            )
    
        try:
            module = importlib.import_module(module_name)
        except ImportError as exc:
&gt;           raise AdapterValidationError(
                f"Failed to import adapter module '{module_name}' for spec '{spec}'."
            ) from exc
E           conftest.AdapterValidationError: Failed to import adapter module 'tests.mocks.mock_llm_adapter' for spec 'tests.mocks.mock_llm_adapter:MockLLMAdapter'.

tests/conftest.py:595: AdapterValidationError</error></testcase></testsuite></testsuites>